<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar System</title>
  <style>
    body { background: #000; color: #fff; text-align: center; font-family: sans-serif; }
    canvas { background: #000; display: block; margin: 0 auto; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.0/astronomy.min.js"></script>
</head>
<body>
  <h1>Solar System</h1>
  <canvas id="solarSystem" width="600" height="600"></canvas>
  <script>
    const canvas = document.getElementById('solarSystem');
    const ctx = canvas.getContext('2d');
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;

    const maxDistance = 220;
    const maxSemiMajorAxis = 30.05; // Neptune's semi-major axis in AU
    const logMax = Math.log(maxSemiMajorAxis + 1);
    const maxPlanetRadius = 69911; // Jupiter radius in km
    const maxDisplayRadius = 12; // Jupiter display radius in px
    const timeScale = 100; // simulation runs 100x faster than real time

    const planetData = [
      { name: 'Mercury', color: '#a9a9a9', radius: 2440, distance: 0.39, period: 88 },
      { name: 'Venus', color: '#f5deb3', radius: 6052, distance: 0.72, period: 225 },
      { name: 'Earth', color: '#1e90ff', radius: 6371, distance: 1.0, period: 365 },
      { name: 'Mars', color: '#ff4500', radius: 3390, distance: 1.52, period: 687 },
      { name: 'Jupiter', color: '#ffa500', radius: 69911, distance: 5.2, period: 4333 },
      { name: 'Saturn', color: '#daa520', radius: 58232, distance: 9.58, period: 10759, hasRings: true },
      { name: 'Uranus', color: '#7fffd4', radius: 25362, distance: 19.2, period: 30688 },
      { name: 'Neptune', color: '#4169e1', radius: 24622, distance: 30.05, period: 60182 }
    ];

    const sun = {
      radius: Math.cbrt(695700) / Math.cbrt(maxPlanetRadius) * maxDisplayRadius,
      color: 'yellow'
    };

    const planets = planetData.map(p => {
      const distance = Math.log(p.distance + 1) / logMax * maxDistance + 20;
      const radius = Math.cbrt(p.radius) / Math.cbrt(maxPlanetRadius) * maxDisplayRadius;
      const angularVelocity = (2 * Math.PI) / p.period; // radians per day
      return { ...p, distance, radius, angularVelocity, angle: 0 };
    });

    const astroTime = Astronomy.MakeTime(new Date());
    planets.forEach(p => {
      const vec = Astronomy.HelioVector(p.name, astroTime);
      p.angle = Math.atan2(vec.y, vec.x);
    });

    let lastTime = performance.now();

    function draw(now) {
      const deltaSeconds = (now - lastTime) / 1000;
      lastTime = now;
      const daysElapsed = deltaSeconds * timeScale / 86400;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      planets.forEach(p => {
        ctx.beginPath();
        ctx.arc(cx, cy, p.distance, 0, Math.PI * 2);
        ctx.stroke();
      });

      ctx.fillStyle = sun.color;
      ctx.beginPath();
      ctx.arc(cx, cy, sun.radius, 0, Math.PI * 2);
      ctx.fill();

      ctx.font = '10px sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';

      planets.forEach(p => {
        p.angle += p.angularVelocity * daysElapsed;
        const x = cx + Math.cos(p.angle) * p.distance;
        const y = cy + Math.sin(p.angle) * p.distance;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(x, y, p.radius, 0, Math.PI * 2);
        ctx.fill();

        if (p.hasRings) {
          ctx.strokeStyle = 'rgba(218,165,32,0.6)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(x, y, p.radius * 2, p.radius * 0.7, 0, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.fillStyle = '#fff';
        ctx.fillText(p.name, x + p.radius + 2, y);
      });

      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
  </script>
</body>
</html>
